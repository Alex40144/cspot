// AUTOGENERATED FILE, DO NOT EDIT BY HAND
#ifndef PB_METADATA_H
#define PB_METADATA_H

#include <memory>
#include <vector>
#include <PbCommon.h>
#include <PbWriter.h>
#include <PbReader.h>

enum class AudioFormat : uint32_t {
    OGG_VORBIS_96 = 0,
    OGG_VORBIS_160 = 1,
    OGG_VORBIS_320 = 2,
    MP3_256 = 3,
    MP3_320 = 4,
    MP3_160 = 5,
    MP3_96 = 6,
    MP3_160_ENC = 7,
    AAC_24 = 8,
    AAC_48 = 9
};

class AudioFile : public BaseProtobufMessage {
private:
public:
    AudioFile() {};
    std::vector<uint8_t> file_id;
    AudioFormat format;
    
    bool decodeField(std::shared_ptr<PbReader> reader)	{
        switch (reader->currentTag)
        {
        case 1:
            reader->decodeVector(file_id);
            break;
        case 2:
            format = static_cast<AudioFormat>(reader->decodeVarInt<uint32_t>());
            break;
        default:
            return false;
        }
        return true;
    }

    void encodeWithWriter(std::shared_ptr<PbWriter> writer) {
        writer->addVector(1, file_id);
        writer->addVarInt(2, static_cast<uint32_t>(format));
    }
};

class Track : public BaseProtobufMessage {
private:
public:
    Track() {};
    std::vector<uint8_t> gid;
    std::string name;
    int32_t duration;
    std::vector<AudioFile> file;
    
    bool decodeField(std::shared_ptr<PbReader> reader)	{
        if (firstField) {
            file.clear();
        }
        switch (reader->currentTag)
        {
        case 1:
            reader->decodeVector(gid);
            break;
        case 2:
            reader->decodeString(name);
            break;
        case 7:
            duration = reader->decodeSVarInt<int32_t>();
            break;
        case 12:
            file.push_back(AudioFile());
            lastMessagePosition = reader->pos + reader->decodeVarInt<uint32_t>();
            file[file.size()-1].parseWithReader(reader);
            reader->maxPosition = lastMessagePosition;
            break;
        default:
            return false;
        }
        return true;
    }

    void encodeWithWriter(std::shared_ptr<PbWriter> writer) {
        writer->addVector(1, gid);
        writer->addString(2, name);
        writer->addSVarInt32(7, duration);
        for (int i = 0; i < file.size(); i++) {
            lastMessagePosition = writer->startMessage();
            file[i].encodeWithWriter(writer);
            writer->finishMessage(12, lastMessagePosition);
        }
    }
};

class Episode : public BaseProtobufMessage {
private:
public:
    Episode() {};
    std::vector<uint8_t> gid;
    std::string name;
    int32_t duration;
    std::vector<AudioFile> audio;
    
    bool decodeField(std::shared_ptr<PbReader> reader)	{
        if (firstField) {
            audio.clear();
        }
        switch (reader->currentTag)
        {
        case 1:
            reader->decodeVector(gid);
            break;
        case 2:
            reader->decodeString(name);
            break;
        case 7:
            duration = reader->decodeSVarInt<int32_t>();
            break;
        case 12:
            audio.push_back(AudioFile());
            lastMessagePosition = reader->pos + reader->decodeVarInt<uint32_t>();
            audio[audio.size()-1].parseWithReader(reader);
            reader->maxPosition = lastMessagePosition;
            break;
        default:
            return false;
        }
        return true;
    }

    void encodeWithWriter(std::shared_ptr<PbWriter> writer) {
        writer->addVector(1, gid);
        writer->addString(2, name);
        writer->addSVarInt32(7, duration);
        for (int i = 0; i < audio.size(); i++) {
            lastMessagePosition = writer->startMessage();
            audio[i].encodeWithWriter(writer);
            writer->finishMessage(12, lastMessagePosition);
        }
    }
};

#endif
