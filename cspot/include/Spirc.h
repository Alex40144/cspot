// AUTOGENERATED FILE, DO NOT EDIT BY HAND
#ifndef PB_SPIRC_H
#define PB_SPIRC_H

#include <memory>
#include <vector>
#include <PbCommon.h>
#include <PbWriter.h>
#include <PbReader.h>

enum class MessageType : uint32_t {
    kMessageTypeHello = 1,
    kMessageTypeGoodbye = 2,
    kMessageTypeProbe = 3,
    kMessageTypeNotify = 10,
    kMessageTypeLoad = 20,
    kMessageTypePlay = 21,
    kMessageTypePause = 22,
    kMessageTypePlayPause = 23,
    kMessageTypeSeek = 24,
    kMessageTypePrev = 25,
    kMessageTypeNext = 26,
    kMessageTypeVolume = 27,
    kMessageTypeShuffle = 28,
    kMessageTypeRepeat = 29,
    kMessageTypeVolumeDown = 31,
    kMessageTypeVolumeUp = 32,
    kMessageTypeReplace = 33,
    kMessageTypeLogout = 34,
    kMessageTypeAction = 35
};

enum class PlayStatus : uint32_t {
    kPlayStatusStop = 0,
    kPlayStatusPlay = 1,
    kPlayStatusPause = 2,
    kPlayStatusLoading = 3
};

enum class CapabilityType : uint32_t {
    kSupportedContexts = 1,
    kCanBePlayer = 2,
    kRestrictToLocal = 3,
    kDeviceType = 4,
    kGaiaEqConnectId = 5,
    kSupportsLogout = 6,
    kIsObservable = 7,
    kVolumeSteps = 8,
    kSupportedTypes = 9,
    kCommandAcks = 10
};

class TrackRef : public BaseProtobufMessage {
private:
public:
    TrackRef() {};
    std::optional<std::vector<uint8_t>> gid;
    std::optional<std::string> uri;
    std::optional<bool> queued;
    std::optional<std::string> context;
    
    bool decodeField(std::shared_ptr<PbReader> reader)	{
        switch (reader->currentTag)
        {
        case 1:
            {
                if (!gid.has_value()) {
                    gid = std::vector<uint8_t>();
                }
                reader->decodeVector(gid.value());
                break;
            }
        case 2:
            {
                if (!uri.has_value()) {
                    uri = std::string();
                }
                reader->decodeString(uri.value());
                break;
            }
        case 3:
            {
                queued = reader->decodeVarInt<bool>();
                break;
            }
        case 4:
            {
                if (!context.has_value()) {
                    context = std::string();
                }
                reader->decodeString(context.value());
                break;
            }
        default:
            return false;
        }
        return true;
    }

    void encodeWithWriter(std::shared_ptr<PbWriter> writer) {
        if (gid.has_value()) {
            writer->addVector(1, gid.value());
        }
        if (uri.has_value()) {
            writer->addString(2, uri.value());
        }
        if (queued.has_value()) {
            writer->addVarInt(3, queued.value());
        }
        if (context.has_value()) {
            writer->addString(4, context.value());
        }
    }
};

class State : public BaseProtobufMessage {
private:
public:
    State() {};
    std::optional<std::string> context_uri;
    std::optional<uint32_t> index;
    std::optional<uint32_t> position_ms;
    std::optional<PlayStatus> status;
    std::optional<uint64_t> position_measured_at;
    std::optional<std::string> context_description;
    std::optional<bool> shuffle;
    std::optional<bool> repeat;
    std::optional<uint32_t> playing_track_index;
    std::optional<std::vector<TrackRef>> track;
    
    bool decodeField(std::shared_ptr<PbReader> reader)	{
        if (firstField) {
            if (!track.has_value()) {
                track = std::vector<TrackRef>();
            }
            track->clear();
        }
        switch (reader->currentTag)
        {
        case 2:
            {
                if (!context_uri.has_value()) {
                    context_uri = std::string();
                }
                reader->decodeString(context_uri.value());
                break;
            }
        case 3:
            {
                index = reader->decodeVarInt<uint32_t>();
                break;
            }
        case 4:
            {
                position_ms = reader->decodeVarInt<uint32_t>();
                break;
            }
        case 5:
            {
                status = static_cast<PlayStatus>(reader->decodeVarInt<uint32_t>());
                break;
            }
        case 7:
            {
                position_measured_at = reader->decodeVarInt<uint64_t>();
                break;
            }
        case 8:
            {
                if (!context_description.has_value()) {
                    context_description = std::string();
                }
                reader->decodeString(context_description.value());
                break;
            }
        case 13:
            {
                shuffle = reader->decodeVarInt<bool>();
                break;
            }
        case 14:
            {
                repeat = reader->decodeVarInt<bool>();
                break;
            }
        case 26:
            {
                playing_track_index = reader->decodeVarInt<uint32_t>();
                break;
            }
        case 27:
            {
                track->push_back(TrackRef());
                lastMessagePosition = reader->maxPosition;
                reader->maxPosition = reader->pos + reader->decodeVarInt<uint32_t>();
                track->at(track->size()-1).parseWithReader(reader);
                reader->maxPosition = lastMessagePosition;
                break;
            }
        default:
            return false;
        }
        return true;
    }

    void encodeWithWriter(std::shared_ptr<PbWriter> writer) {
        if (context_uri.has_value()) {
            writer->addString(2, context_uri.value());
        }
        if (index.has_value()) {
            writer->addVarInt(3, index.value());
        }
        if (position_ms.has_value()) {
            writer->addVarInt(4, position_ms.value());
        }
        if (status.has_value()) {
            writer->addVarInt(5, static_cast<uint32_t>(status.value()));
        }
        if (position_measured_at.has_value()) {
            writer->addVarInt(7, position_measured_at.value());
        }
        if (context_description.has_value()) {
            writer->addString(8, context_description.value());
        }
        if (shuffle.has_value()) {
            writer->addVarInt(13, shuffle.value());
        }
        if (repeat.has_value()) {
            writer->addVarInt(14, repeat.value());
        }
        if (playing_track_index.has_value()) {
            writer->addVarInt(26, playing_track_index.value());
        }
        if (track.has_value()) {
            for (int i = 0; i < track->size(); i++) {
                lastMessagePosition = writer->startMessage();
                track->at(i).encodeWithWriter(writer);
                writer->finishMessage(27, lastMessagePosition);
            }
        }
    }
};

class Capability : public BaseProtobufMessage {
private:
public:
    Capability() {};
    std::optional<CapabilityType> typ;
    std::optional<std::vector<int64_t>> intValue;
    std::optional<std::vector<std::string>> stringValue;
    
    bool decodeField(std::shared_ptr<PbReader> reader)	{
        if (firstField) {
            if (!intValue.has_value()) {
                intValue = std::vector<int64_t>();
            }
            intValue->clear();
            if (!stringValue.has_value()) {
                stringValue = std::vector<std::string>();
            }
            stringValue->clear();
        }
        switch (reader->currentTag)
        {
        case 1:
            {
                typ = static_cast<CapabilityType>(reader->decodeVarInt<uint32_t>());
                break;
            }
        case 2:
            {
                lastMessagePosition = reader->pos + reader->decodeVarInt<uint32_t>();
                while (reader->pos < lastMessagePosition) {
                    intValue->push_back(reader->decodeVarInt<int64_t>());
                }
                break;
            }
        case 3:
            {
                stringValue->push_back(std::string());
                reader->decodeString(stringValue->at(stringValue->size()-1));
                break;
            }
        default:
            return false;
        }
        return true;
    }

    void encodeWithWriter(std::shared_ptr<PbWriter> writer) {
        if (typ.has_value()) {
            writer->addVarInt(1, static_cast<uint32_t>(typ.value()));
        }
        if (intValue.has_value()) {
            lastMessagePosition = writer->startMessage();
            for (int i = 0; i < intValue->size(); i++) {
                writer->encodeVarInt(intValue->at(i));
            }
            writer->finishMessage(2, lastMessagePosition);
        }
        if (stringValue.has_value()) {
            for (int i = 0; i < stringValue->size(); i++) {
                writer->addString(3, stringValue.value().at(i));
            }
        }
    }
};

class DeviceState : public BaseProtobufMessage {
private:
public:
    DeviceState() {};
    std::optional<std::string> sw_version;
    std::optional<bool> is_active;
    std::optional<bool> can_play;
    std::optional<uint32_t> volume;
    std::optional<std::string> name;
    std::optional<uint32_t> error_code;
    std::optional<int64_t> became_active_at;
    std::optional<std::string> error_message;
    std::optional<std::vector<Capability>> capabilities;
    std::optional<std::vector<std::string>> local_uris;
    
    bool decodeField(std::shared_ptr<PbReader> reader)	{
        if (firstField) {
            if (!capabilities.has_value()) {
                capabilities = std::vector<Capability>();
            }
            capabilities->clear();
            if (!local_uris.has_value()) {
                local_uris = std::vector<std::string>();
            }
            local_uris->clear();
        }
        switch (reader->currentTag)
        {
        case 1:
            {
                if (!sw_version.has_value()) {
                    sw_version = std::string();
                }
                reader->decodeString(sw_version.value());
                break;
            }
        case 10:
            {
                is_active = reader->decodeVarInt<bool>();
                break;
            }
        case 11:
            {
                can_play = reader->decodeVarInt<bool>();
                break;
            }
        case 12:
            {
                volume = reader->decodeVarInt<uint32_t>();
                break;
            }
        case 13:
            {
                if (!name.has_value()) {
                    name = std::string();
                }
                reader->decodeString(name.value());
                break;
            }
        case 14:
            {
                error_code = reader->decodeVarInt<uint32_t>();
                break;
            }
        case 15:
            {
                became_active_at = reader->decodeVarInt<int64_t>();
                break;
            }
        case 16:
            {
                if (!error_message.has_value()) {
                    error_message = std::string();
                }
                reader->decodeString(error_message.value());
                break;
            }
        case 17:
            {
                capabilities->push_back(Capability());
                lastMessagePosition = reader->maxPosition;
                reader->maxPosition = reader->pos + reader->decodeVarInt<uint32_t>();
                capabilities->at(capabilities->size()-1).parseWithReader(reader);
                reader->maxPosition = lastMessagePosition;
                break;
            }
        case 18:
            {
                local_uris->push_back(std::string());
                reader->decodeString(local_uris->at(local_uris->size()-1));
                break;
            }
        default:
            return false;
        }
        return true;
    }

    void encodeWithWriter(std::shared_ptr<PbWriter> writer) {
        if (sw_version.has_value()) {
            writer->addString(1, sw_version.value());
        }
        if (is_active.has_value()) {
            writer->addVarInt(10, is_active.value());
        }
        if (can_play.has_value()) {
            writer->addVarInt(11, can_play.value());
        }
        if (volume.has_value()) {
            writer->addVarInt(12, volume.value());
        }
        if (name.has_value()) {
            writer->addString(13, name.value());
        }
        if (error_code.has_value()) {
            writer->addVarInt(14, error_code.value());
        }
        if (became_active_at.has_value()) {
            writer->addVarInt(15, became_active_at.value());
        }
        if (error_message.has_value()) {
            writer->addString(16, error_message.value());
        }
        if (capabilities.has_value()) {
            for (int i = 0; i < capabilities->size(); i++) {
                lastMessagePosition = writer->startMessage();
                capabilities->at(i).encodeWithWriter(writer);
                writer->finishMessage(17, lastMessagePosition);
            }
        }
        if (local_uris.has_value()) {
            for (int i = 0; i < local_uris->size(); i++) {
                writer->addString(18, local_uris.value().at(i));
            }
        }
    }
};

class Frame : public BaseProtobufMessage {
private:
public:
    Frame() {};
    std::optional<uint32_t> version;
    std::optional<std::string> ident;
    std::optional<std::string> protocol_version;
    std::optional<uint32_t> seq_nr;
    std::optional<MessageType> typ;
    std::optional<DeviceState> device_state;
    std::optional<State> state;
    std::optional<uint32_t> position;
    std::optional<uint32_t> volume;
    std::optional<int64_t> state_update_id;
    std::optional<std::vector<std::string>> recipient;
    
    bool decodeField(std::shared_ptr<PbReader> reader)	{
        if (firstField) {
            if (!recipient.has_value()) {
                recipient = std::vector<std::string>();
            }
            recipient->clear();
        }
        switch (reader->currentTag)
        {
        case 1:
            {
                version = reader->decodeVarInt<uint32_t>();
                break;
            }
        case 2:
            {
                if (!ident.has_value()) {
                    ident = std::string();
                }
                reader->decodeString(ident.value());
                break;
            }
        case 3:
            {
                if (!protocol_version.has_value()) {
                    protocol_version = std::string();
                }
                reader->decodeString(protocol_version.value());
                break;
            }
        case 4:
            {
                seq_nr = reader->decodeVarInt<uint32_t>();
                break;
            }
        case 5:
            {
                typ = static_cast<MessageType>(reader->decodeVarInt<uint32_t>());
                break;
            }
        case 7:
            {
                if (!device_state.has_value()) {
                    device_state = DeviceState();
                }
                lastMessagePosition = reader->maxPosition;
                reader->maxPosition = reader->pos + reader->decodeVarInt<uint32_t>();
                device_state->parseWithReader(reader);
                reader->maxPosition = lastMessagePosition;
                break;
            }
        case 12:
            {
                if (!state.has_value()) {
                    state = State();
                }
                lastMessagePosition = reader->maxPosition;
                reader->maxPosition = reader->pos + reader->decodeVarInt<uint32_t>();
                state->parseWithReader(reader);
                reader->maxPosition = lastMessagePosition;
                break;
            }
        case 13:
            {
                position = reader->decodeVarInt<uint32_t>();
                break;
            }
        case 14:
            {
                volume = reader->decodeVarInt<uint32_t>();
                break;
            }
        case 17:
            {
                state_update_id = reader->decodeVarInt<int64_t>();
                break;
            }
        case 18:
            {
                recipient->push_back(std::string());
                reader->decodeString(recipient->at(recipient->size()-1));
                break;
            }
        default:
            return false;
        }
        return true;
    }

    void encodeWithWriter(std::shared_ptr<PbWriter> writer) {
        if (version.has_value()) {
            writer->addVarInt(1, version.value());
        }
        if (ident.has_value()) {
            writer->addString(2, ident.value());
        }
        if (protocol_version.has_value()) {
            writer->addString(3, protocol_version.value());
        }
        if (seq_nr.has_value()) {
            writer->addVarInt(4, seq_nr.value());
        }
        if (typ.has_value()) {
            writer->addVarInt(5, static_cast<uint32_t>(typ.value()));
        }
        if (device_state.has_value()) {
            lastMessagePosition = writer->startMessage();
            device_state->encodeWithWriter(writer);
            writer->finishMessage(7, lastMessagePosition);
        }
        if (state.has_value()) {
            lastMessagePosition = writer->startMessage();
            state->encodeWithWriter(writer);
            writer->finishMessage(12, lastMessagePosition);
        }
        if (position.has_value()) {
            writer->addVarInt(13, position.value());
        }
        if (volume.has_value()) {
            writer->addVarInt(14, volume.value());
        }
        if (state_update_id.has_value()) {
            writer->addVarInt(17, state_update_id.value());
        }
        if (recipient.has_value()) {
            for (int i = 0; i < recipient->size(); i++) {
                writer->addString(18, recipient.value().at(i));
            }
        }
    }
};

#endif
